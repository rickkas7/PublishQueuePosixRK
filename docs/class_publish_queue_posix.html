<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueuePosixRK: PublishQueuePosix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PublishQueuePosixRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">PublishQueuePosix Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for asynchronous publishing of events.  
 <a href="class_publish_queue_posix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_publish_queue_posix_r_k_8h_source.html">PublishQueuePosixRK.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9b64145e8d3d2221f1a71a3368b1f29e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a9b64145e8d3d2221f1a71a3368b1f29e">withRamQueueSize</a> (size_t size)</td></tr>
<tr class="memdesc:a9b64145e8d3d2221f1a71a3368b1f29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RAM based queue size (default is 2)  <br /></td></tr>
<tr class="separator:a9b64145e8d3d2221f1a71a3368b1f29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9de217df46af588b7b95c5f3ae339d"><td class="memItemLeft" align="right" valign="top"><a id="a7e9de217df46af588b7b95c5f3ae339d" name="a7e9de217df46af588b7b95c5f3ae339d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getRamQueueSize</b> () const</td></tr>
<tr class="memdesc:a7e9de217df46af588b7b95c5f3ae339d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the RAM queue. <br /></td></tr>
<tr class="separator:a7e9de217df46af588b7b95c5f3ae339d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5963d98e3b9c4e1254cedd4cb0d3a89c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a5963d98e3b9c4e1254cedd4cb0d3a89c">withFileQueueSize</a> (size_t size)</td></tr>
<tr class="memdesc:a5963d98e3b9c4e1254cedd4cb0d3a89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the file-based queue size (default is 100)  <br /></td></tr>
<tr class="separator:a5963d98e3b9c4e1254cedd4cb0d3a89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceda8818c2265cfd11ec63ecbe63b42"><td class="memItemLeft" align="right" valign="top"><a id="a4ceda8818c2265cfd11ec63ecbe63b42" name="a4ceda8818c2265cfd11ec63ecbe63b42"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getFileQueueSize</b> () const</td></tr>
<tr class="memdesc:a4ceda8818c2265cfd11ec63ecbe63b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the file queue size. <br /></td></tr>
<tr class="separator:a4ceda8818c2265cfd11ec63ecbe63b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebea9de0fa9df57fcae3bda39bead02f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#aebea9de0fa9df57fcae3bda39bead02f">withDirPath</a> (const char *dirPath)</td></tr>
<tr class="memdesc:aebea9de0fa9df57fcae3bda39bead02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the directory to use as the queue directory. This is required!  <br /></td></tr>
<tr class="separator:aebea9de0fa9df57fcae3bda39bead02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3222ff156a5b65e3cca85ce199e566"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#acc3222ff156a5b65e3cca85ce199e566">getDirPath</a> () const</td></tr>
<tr class="memdesc:acc3222ff156a5b65e3cca85ce199e566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the directory path set using <a class="el" href="class_publish_queue_posix.html#aebea9de0fa9df57fcae3bda39bead02f" title="Sets the directory to use as the queue directory. This is required!">withDirPath()</a>  <br /></td></tr>
<tr class="separator:acc3222ff156a5b65e3cca85ce199e566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2e79c07a1e1a50016e53d3c75a28d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#aeb2e79c07a1e1a50016e53d3c75a28d4">withPublishCompleteUserCallback</a> (std::function&lt; void(bool succeeded, const char *eventName, const char *eventData)&gt; cb)</td></tr>
<tr class="memdesc:aeb2e79c07a1e1a50016e53d3c75a28d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback function to call with publish is complete.  <br /></td></tr>
<tr class="separator:aeb2e79c07a1e1a50016e53d3c75a28d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8590bc7920dad66e85ed60c65ecd867"><td class="memItemLeft" align="right" valign="top"><a id="ad8590bc7920dad66e85ed60c65ecd867" name="ad8590bc7920dad66e85ed60c65ecd867"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setup</b> ()</td></tr>
<tr class="memdesc:ad8590bc7920dad66e85ed60c65ecd867"><td class="mdescLeft">&#160;</td><td class="mdescRight">You must call this from <a class="el" href="class_publish_queue_posix.html#ad8590bc7920dad66e85ed60c65ecd867" title="You must call this from setup() to initialize this library.">setup()</a> to initialize this library. <br /></td></tr>
<tr class="separator:ad8590bc7920dad66e85ed60c65ecd867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157e71d583df634b290b5ab3e08156f5"><td class="memItemLeft" align="right" valign="top"><a id="a157e71d583df634b290b5ab3e08156f5" name="a157e71d583df634b290b5ab3e08156f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loop</b> ()</td></tr>
<tr class="memdesc:a157e71d583df634b290b5ab3e08156f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">You must call the loop method from the global <a class="el" href="class_publish_queue_posix.html#a157e71d583df634b290b5ab3e08156f5" title="You must call the loop method from the global loop() function!">loop()</a> function! <br /></td></tr>
<tr class="separator:a157e71d583df634b290b5ab3e08156f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcadc762c4c3e889920997f0e9cd1de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a2bcadc762c4c3e889920997f0e9cd1de">publish</a> (const char *eventName, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a2bcadc762c4c3e889920997f0e9cd1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <br /></td></tr>
<tr class="separator:a2bcadc762c4c3e889920997f0e9cd1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab078360beeedbc6fe4e0f3fddedcae25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#ab078360beeedbc6fe4e0f3fddedcae25">publish</a> (const char *eventName, const char *data, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:ab078360beeedbc6fe4e0f3fddedcae25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <br /></td></tr>
<tr class="separator:ab078360beeedbc6fe4e0f3fddedcae25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b3c8a1a1a542d1423bc604e4012840"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a45b3c8a1a1a542d1423bc604e4012840">publish</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a45b3c8a1a1a542d1423bc604e4012840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for publishing an event.  <br /></td></tr>
<tr class="separator:a45b3c8a1a1a542d1423bc604e4012840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe70d82680b20968aa151d7ec953bc5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a1fe70d82680b20968aa151d7ec953bc5">publishCommon</a> (const char *eventName, const char *data, int ttl, PublishFlags flags1, PublishFlags flags2=PublishFlags())</td></tr>
<tr class="memdesc:a1fe70d82680b20968aa151d7ec953bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses.  <br /></td></tr>
<tr class="separator:a1fe70d82680b20968aa151d7ec953bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25ae4430b968cee10a91c72c9ed41f4"><td class="memItemLeft" align="right" valign="top"><a id="ae25ae4430b968cee10a91c72c9ed41f4" name="ae25ae4430b968cee10a91c72c9ed41f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writeQueueToFiles</b> ()</td></tr>
<tr class="memdesc:ae25ae4430b968cee10a91c72c9ed41f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there are events in the RAM queue, write them to files in the flash file system. <br /></td></tr>
<tr class="separator:ae25ae4430b968cee10a91c72c9ed41f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd1346256db17582e210c544735bc66"><td class="memItemLeft" align="right" valign="top"><a id="afdd1346256db17582e210c544735bc66" name="afdd1346256db17582e210c544735bc66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearQueues</b> ()</td></tr>
<tr class="memdesc:afdd1346256db17582e210c544735bc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty both the RAM and file based queues. Any queued events are discarded. <br /></td></tr>
<tr class="separator:afdd1346256db17582e210c544735bc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2198975a45927d31a79b37c91addf06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a2198975a45927d31a79b37c91addf06e">setPausePublishing</a> (bool value)</td></tr>
<tr class="memdesc:a2198975a45927d31a79b37c91addf06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause or resume publishing events.  <br /></td></tr>
<tr class="separator:a2198975a45927d31a79b37c91addf06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10fe9f388241227f5e431a23ac0c980"><td class="memItemLeft" align="right" valign="top"><a id="ae10fe9f388241227f5e431a23ac0c980" name="ae10fe9f388241227f5e431a23ac0c980"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getPausePublishing</b> () const</td></tr>
<tr class="memdesc:ae10fe9f388241227f5e431a23ac0c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the state of the pause publishing flag. <br /></td></tr>
<tr class="separator:ae10fe9f388241227f5e431a23ac0c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf40ee8cdda04825a5cd39a0e590ee29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#aaf40ee8cdda04825a5cd39a0e590ee29">getCanSleep</a> () const</td></tr>
<tr class="memdesc:aaf40ee8cdda04825a5cd39a0e590ee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if it's a good time to go to sleep.  <br /></td></tr>
<tr class="separator:aaf40ee8cdda04825a5cd39a0e590ee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e04445ef87bdfdf78fc5d7a2a67ac46"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a1e04445ef87bdfdf78fc5d7a2a67ac46">getNumEvents</a> ()</td></tr>
<tr class="memdesc:a1e04445ef87bdfdf78fc5d7a2a67ac46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the total number of events queued.  <br /></td></tr>
<tr class="separator:a1e04445ef87bdfdf78fc5d7a2a67ac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4cfe79ff30c443477d9436a8f17c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a8c4cfe79ff30c443477d9436a8f17c02">checkQueueLimits</a> ()</td></tr>
<tr class="memdesc:a8c4cfe79ff30c443477d9436a8f17c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the queue limit, discarding events as necessary.  <br /></td></tr>
<tr class="separator:a8c4cfe79ff30c443477d9436a8f17c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e26d5d2fb67931b3505bcea140d6b6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a9e26d5d2fb67931b3505bcea140d6b6a">lock</a> ()</td></tr>
<tr class="memdesc:a9e26d5d2fb67931b3505bcea140d6b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the queue protection mutex.  <br /></td></tr>
<tr class="separator:a9e26d5d2fb67931b3505bcea140d6b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d31a0910bf63b36cdf44e19e7e6f05"><td class="memItemLeft" align="right" valign="top"><a id="ad8d31a0910bf63b36cdf44e19e7e6f05" name="ad8d31a0910bf63b36cdf44e19e7e6f05"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tryLock</b> ()</td></tr>
<tr class="memdesc:ad8d31a0910bf63b36cdf44e19e7e6f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt the queue protection mutex. <br /></td></tr>
<tr class="separator:ad8d31a0910bf63b36cdf44e19e7e6f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5179e3090335f23f2f882f274c5a7d2"><td class="memItemLeft" align="right" valign="top"><a id="ad5179e3090335f23f2f882f274c5a7d2" name="ad5179e3090335f23f2f882f274c5a7d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock</b> ()</td></tr>
<tr class="memdesc:ad5179e3090335f23f2f882f274c5a7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the queue protection mutex. <br /></td></tr>
<tr class="separator:ad5179e3090335f23f2f882f274c5a7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af641a55b459d3a0b465945bc87f8c9e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#af641a55b459d3a0b465945bc87f8c9e4">instance</a> ()</td></tr>
<tr class="memdesc:af641a55b459d3a0b465945bc87f8c9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the singleton instance of this class.  <br /></td></tr>
<tr class="separator:af641a55b459d3a0b465945bc87f8c9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aecb694d40a65f4073b8615515c498426"><td class="memItemLeft" align="right" valign="top"><a id="aecb694d40a65f4073b8615515c498426" name="aecb694d40a65f4073b8615515c498426"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>FILE_MAGIC</b> = 0x31b67663</td></tr>
<tr class="memdesc:aecb694d40a65f4073b8615515c498426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic bytes store at the beginning of event files for validity checking. <br /></td></tr>
<tr class="separator:aecb694d40a65f4073b8615515c498426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4693549cdb01bbf38663b6a250232e91"><td class="memItemLeft" align="right" valign="top"><a id="a4693549cdb01bbf38663b6a250232e91" name="a4693549cdb01bbf38663b6a250232e91"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>FILE_VERSION</b> = 1</td></tr>
<tr class="memdesc:a4693549cdb01bbf38663b6a250232e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of the file header for events. <br /></td></tr>
<tr class="separator:a4693549cdb01bbf38663b6a250232e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7985d5f2907b43c2701c3747d536a0d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a7985d5f2907b43c2701c3747d536a0d0">PublishQueuePosix</a> ()</td></tr>
<tr class="memdesc:a7985d5f2907b43c2701c3747d536a0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a7985d5f2907b43c2701c3747d536a0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa133b470d647fb58a5c585bf9b262aa6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#aa133b470d647fb58a5c585bf9b262aa6">~PublishQueuePosix</a> ()</td></tr>
<tr class="memdesc:aa133b470d647fb58a5c585bf9b262aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:aa133b470d647fb58a5c585bf9b262aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c89ec0d002ef14732476a7ac7b7008"><td class="memItemLeft" align="right" valign="top"><a id="a65c89ec0d002ef14732476a7ac7b7008" name="a65c89ec0d002ef14732476a7ac7b7008"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PublishQueuePosix</b> (const <a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp;)=delete</td></tr>
<tr class="memdesc:a65c89ec0d002ef14732476a7ac7b7008"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a65c89ec0d002ef14732476a7ac7b7008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45116364d7ac7909a8b8e49ac65a8ee6"><td class="memItemLeft" align="right" valign="top"><a id="a45116364d7ac7909a8b8e49ac65a8ee6" name="a45116364d7ac7909a8b8e49ac65a8ee6"></a>
<a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp;)=delete</td></tr>
<tr class="memdesc:a45116364d7ac7909a8b8e49ac65a8ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a45116364d7ac7909a8b8e49ac65a8ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dcc28e7d37ac0e565c3868819cd8cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_publish_queue_event.html">PublishQueueEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a03dcc28e7d37ac0e565c3868819cd8cb">newRamEvent</a> (const char *eventName, const char *eventData, PublishFlags flags)</td></tr>
<tr class="memdesc:a03dcc28e7d37ac0e565c3868819cd8cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new event structure in RAM.  <br /></td></tr>
<tr class="separator:a03dcc28e7d37ac0e565c3868819cd8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0898b3b24cfb9eb156d35f74fff12ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_publish_queue_event.html">PublishQueueEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#ab0898b3b24cfb9eb156d35f74fff12ce">readQueueFile</a> (int fileNum)</td></tr>
<tr class="memdesc:ab0898b3b24cfb9eb156d35f74fff12ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an event from a sequentially numbered file.  <br /></td></tr>
<tr class="separator:ab0898b3b24cfb9eb156d35f74fff12ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802d684d2498d64ae99e5e90edf4acb1"><td class="memItemLeft" align="right" valign="top"><a id="a802d684d2498d64ae99e5e90edf4acb1" name="a802d684d2498d64ae99e5e90edf4acb1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>publishCompleteCallback</b> (bool succeeded, const char *eventName, const char *eventData)</td></tr>
<tr class="memdesc:a802d684d2498d64ae99e5e90edf4acb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for BackgroundPublishRK library. <br /></td></tr>
<tr class="separator:a802d684d2498d64ae99e5e90edf4acb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c7fb70b600e93c585caf85fbcf8665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#ac5c7fb70b600e93c585caf85fbcf8665">stateConnectWait</a> ()</td></tr>
<tr class="memdesc:ac5c7fb70b600e93c585caf85fbcf8665"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler for waiting to connect to the Particle cloud.  <br /></td></tr>
<tr class="separator:ac5c7fb70b600e93c585caf85fbcf8665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120b8d168445713bfb825cedc613e314"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#a120b8d168445713bfb825cedc613e314">stateWait</a> ()</td></tr>
<tr class="memdesc:a120b8d168445713bfb825cedc613e314"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler for waiting to publish.  <br /></td></tr>
<tr class="separator:a120b8d168445713bfb825cedc613e314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b3ff26f26c5bf30fc721feb4bc3e3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_publish_queue_posix.html#aa8b3ff26f26c5bf30fc721feb4bc3e3a">statePublishWait</a> ()</td></tr>
<tr class="memdesc:aa8b3ff26f26c5bf30fc721feb4bc3e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler for waiting for publish to complete.  <br /></td></tr>
<tr class="separator:aa8b3ff26f26c5bf30fc721feb4bc3e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a5119c4048d829dc9c269a84e385723d4"><td class="memItemLeft" align="right" valign="top"><a id="a5119c4048d829dc9c269a84e385723d4" name="a5119c4048d829dc9c269a84e385723d4"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>systemEventHandler</b> (system_event_t event, int param)</td></tr>
<tr class="memdesc:a5119c4048d829dc9c269a84e385723d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">system event handler, used to detect reset events <br /></td></tr>
<tr class="separator:a5119c4048d829dc9c269a84e385723d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a995d3761ad8a13aa27fe735b4a496ca7"><td class="memItemLeft" align="right" valign="top"><a id="a995d3761ad8a13aa27fe735b4a496ca7" name="a995d3761ad8a13aa27fe735b4a496ca7"></a>
SequentialFile&#160;</td><td class="memItemRight" valign="bottom"><b>fileQueue</b></td></tr>
<tr class="memdesc:a995d3761ad8a13aa27fe735b4a496ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SequentialFileRK library object for maintaining the queue of files on the POSIX file system. <br /></td></tr>
<tr class="separator:a995d3761ad8a13aa27fe735b4a496ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a051e66483643ae0e77feeac488f080"><td class="memItemLeft" align="right" valign="top"><a id="a3a051e66483643ae0e77feeac488f080" name="a3a051e66483643ae0e77feeac488f080"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ramQueueSize</b> = 2</td></tr>
<tr class="memdesc:a3a051e66483643ae0e77feeac488f080"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the queue in RAM <br /></td></tr>
<tr class="separator:a3a051e66483643ae0e77feeac488f080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b89e31e3197507722366a19161f318"><td class="memItemLeft" align="right" valign="top"><a id="a09b89e31e3197507722366a19161f318" name="a09b89e31e3197507722366a19161f318"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>fileQueueSize</b> = 100</td></tr>
<tr class="memdesc:a09b89e31e3197507722366a19161f318"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the queue on the flash file system <br /></td></tr>
<tr class="separator:a09b89e31e3197507722366a19161f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a223f5885717703b29921635bc45a57"><td class="memItemLeft" align="right" valign="top"><a id="a6a223f5885717703b29921635bc45a57" name="a6a223f5885717703b29921635bc45a57"></a>
os_mutex_recursive_t&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b></td></tr>
<tr class="memdesc:a6a223f5885717703b29921635bc45a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex for protecting the queue <br /></td></tr>
<tr class="separator:a6a223f5885717703b29921635bc45a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40405a37e608305063e3538a7684107f"><td class="memItemLeft" align="right" valign="top"><a id="a40405a37e608305063e3538a7684107f" name="a40405a37e608305063e3538a7684107f"></a>
std::deque&lt; <a class="el" href="struct_publish_queue_event.html">PublishQueueEvent</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ramQueue</b></td></tr>
<tr class="memdesc:a40405a37e608305063e3538a7684107f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue in RAM. <br /></td></tr>
<tr class="separator:a40405a37e608305063e3538a7684107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb022c11505d323d13a644e6439512b"><td class="memItemLeft" align="right" valign="top"><a id="a7fb022c11505d323d13a644e6439512b" name="a7fb022c11505d323d13a644e6439512b"></a>
<a class="el" href="struct_publish_queue_event.html">PublishQueueEvent</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>curEvent</b> = 0</td></tr>
<tr class="memdesc:a7fb022c11505d323d13a644e6439512b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current event being published. <br /></td></tr>
<tr class="separator:a7fb022c11505d323d13a644e6439512b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac434c4dd7fb1d30d7f3c06460ccc6ca5"><td class="memItemLeft" align="right" valign="top"><a id="ac434c4dd7fb1d30d7f3c06460ccc6ca5" name="ac434c4dd7fb1d30d7f3c06460ccc6ca5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>curFileNum</b> = 0</td></tr>
<tr class="memdesc:ac434c4dd7fb1d30d7f3c06460ccc6ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current file number being published (0 if from RAM queue) <br /></td></tr>
<tr class="separator:ac434c4dd7fb1d30d7f3c06460ccc6ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d8e165d5730fb66c08c2fe656feadc"><td class="memItemLeft" align="right" valign="top"><a id="a94d8e165d5730fb66c08c2fe656feadc" name="a94d8e165d5730fb66c08c2fe656feadc"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>stateTime</b> = 0</td></tr>
<tr class="memdesc:a94d8e165d5730fb66c08c2fe656feadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">millis() value when entering the state, used for stateWait <br /></td></tr>
<tr class="separator:a94d8e165d5730fb66c08c2fe656feadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496c14c637d046b4544f350a2d1386af"><td class="memItemLeft" align="right" valign="top"><a id="a496c14c637d046b4544f350a2d1386af" name="a496c14c637d046b4544f350a2d1386af"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>durationMs</b> = 0</td></tr>
<tr class="memdesc:a496c14c637d046b4544f350a2d1386af"><td class="mdescLeft">&#160;</td><td class="mdescRight">how long to wait before publishing in milliseconds, used in stateWait <br /></td></tr>
<tr class="separator:a496c14c637d046b4544f350a2d1386af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a4e5cd712bb523050fe07b227b870a"><td class="memItemLeft" align="right" valign="top"><a id="ab7a4e5cd712bb523050fe07b227b870a" name="ab7a4e5cd712bb523050fe07b227b870a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>publishComplete</b> = false</td></tr>
<tr class="memdesc:ab7a4e5cd712bb523050fe07b227b870a"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the publish has completed (successfully or not) <br /></td></tr>
<tr class="separator:ab7a4e5cd712bb523050fe07b227b870a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5db3dcd4a98a489201586fa22c76a8"><td class="memItemLeft" align="right" valign="top"><a id="a5c5db3dcd4a98a489201586fa22c76a8" name="a5c5db3dcd4a98a489201586fa22c76a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>publishSuccess</b> = false</td></tr>
<tr class="memdesc:a5c5db3dcd4a98a489201586fa22c76a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the publish succeeded <br /></td></tr>
<tr class="separator:a5c5db3dcd4a98a489201586fa22c76a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fcd50e137cd4d3579723bc74e49204"><td class="memItemLeft" align="right" valign="top"><a id="ad5fcd50e137cd4d3579723bc74e49204" name="ad5fcd50e137cd4d3579723bc74e49204"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>pausePublishing</b> = false</td></tr>
<tr class="memdesc:ad5fcd50e137cd4d3579723bc74e49204"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to pause publishing (used from automated test) <br /></td></tr>
<tr class="separator:ad5fcd50e137cd4d3579723bc74e49204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff0f7824b7cf6adbdb933f697be63d4"><td class="memItemLeft" align="right" valign="top"><a id="adff0f7824b7cf6adbdb933f697be63d4" name="adff0f7824b7cf6adbdb933f697be63d4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>canSleep</b> = false</td></tr>
<tr class="memdesc:adff0f7824b7cf6adbdb933f697be63d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if this is a good time to go to sleep <br /></td></tr>
<tr class="separator:adff0f7824b7cf6adbdb933f697be63d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92a2d4304a3f26cbe9320929b2a93f2"><td class="memItemLeft" align="right" valign="top"><a id="ac92a2d4304a3f26cbe9320929b2a93f2" name="ac92a2d4304a3f26cbe9320929b2a93f2"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>waitAfterConnect</b> = 2000</td></tr>
<tr class="memdesc:ac92a2d4304a3f26cbe9320929b2a93f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">time to wait after Particle.connected() before publishing <br /></td></tr>
<tr class="separator:ac92a2d4304a3f26cbe9320929b2a93f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6fffc699a392ade44e82a92f1ce6de"><td class="memItemLeft" align="right" valign="top"><a id="a7e6fffc699a392ade44e82a92f1ce6de" name="a7e6fffc699a392ade44e82a92f1ce6de"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>waitBetweenPublish</b> = 1000</td></tr>
<tr class="memdesc:a7e6fffc699a392ade44e82a92f1ce6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">how long to wait in milliseconds between publishes <br /></td></tr>
<tr class="separator:a7e6fffc699a392ade44e82a92f1ce6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d04242d6e3cef2baac40e461da0e691"><td class="memItemLeft" align="right" valign="top"><a id="a5d04242d6e3cef2baac40e461da0e691" name="a5d04242d6e3cef2baac40e461da0e691"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>waitAfterFailure</b> = 30000</td></tr>
<tr class="memdesc:a5d04242d6e3cef2baac40e461da0e691"><td class="mdescLeft">&#160;</td><td class="mdescRight">how long to wait after failing to publish before trying again <br /></td></tr>
<tr class="separator:a5d04242d6e3cef2baac40e461da0e691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe314e63d4894e6ba7929da5d89fc7b"><td class="memItemLeft" align="right" valign="top"><a id="aabe314e63d4894e6ba7929da5d89fc7b" name="aabe314e63d4894e6ba7929da5d89fc7b"></a>
std::function&lt; void(bool succeeded, const char *eventName, const char *eventData)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>publishCompleteUserCallback</b> = 0</td></tr>
<tr class="memdesc:aabe314e63d4894e6ba7929da5d89fc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">User callback for publish complete. <br /></td></tr>
<tr class="separator:aabe314e63d4894e6ba7929da5d89fc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35be57ccbb4ee793bd143c8c501a1594"><td class="memItemLeft" align="right" valign="top"><a id="a35be57ccbb4ee793bd143c8c501a1594" name="a35be57ccbb4ee793bd143c8c501a1594"></a>
std::function&lt; void(<a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stateHandler</b> = 0</td></tr>
<tr class="memdesc:a35be57ccbb4ee793bd143c8c501a1594"><td class="mdescLeft">&#160;</td><td class="mdescRight">state handler (stateConnectWait, stateWait, etc). <br /></td></tr>
<tr class="separator:a35be57ccbb4ee793bd143c8c501a1594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:af6e2bb49850513577f7356fa63c9cf99"><td class="memItemLeft" align="right" valign="top"><a id="af6e2bb49850513577f7356fa63c9cf99" name="af6e2bb49850513577f7356fa63c9cf99"></a>
static <a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_instance</b></td></tr>
<tr class="memdesc:af6e2bb49850513577f7356fa63c9cf99"><td class="mdescLeft">&#160;</td><td class="mdescRight">singleton instance of this class <br /></td></tr>
<tr class="separator:af6e2bb49850513577f7356fa63c9cf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for asynchronous publishing of events. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7985d5f2907b43c2701c3747d536a0d0" name="a7985d5f2907b43c2701c3747d536a0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7985d5f2907b43c2701c3747d536a0d0">&#9670;&#160;</a></span>PublishQueuePosix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PublishQueuePosix::PublishQueuePosix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>This class is a singleton; you never create one of these directly. Use <a class="el" href="class_publish_queue_posix.html#af641a55b459d3a0b465945bc87f8c9e4" title="Gets the singleton instance of this class.">PublishQueuePosix::instance()</a> to get the singleton instance. </p>

</div>
</div>
<a id="aa133b470d647fb58a5c585bf9b262aa6" name="aa133b470d647fb58a5c585bf9b262aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa133b470d647fb58a5c585bf9b262aa6">&#9670;&#160;</a></span>~PublishQueuePosix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PublishQueuePosix::~PublishQueuePosix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This class is never deleted; once the singleton is created it cannot be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c4cfe79ff30c443477d9436a8f17c02" name="a8c4cfe79ff30c443477d9436a8f17c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4cfe79ff30c443477d9436a8f17c02">&#9670;&#160;</a></span>checkQueueLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueuePosix::checkQueueLimits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the queue limit, discarding events as necessary. </p>
<p>When the RAM queue exceeds the limit, all events are moved into files. </p>

</div>
</div>
<a id="aaf40ee8cdda04825a5cd39a0e590ee29" name="aaf40ee8cdda04825a5cd39a0e590ee29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf40ee8cdda04825a5cd39a0e590ee29">&#9670;&#160;</a></span>getCanSleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueuePosix::getCanSleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if it's a good time to go to sleep. </p>
<p>If a publish is not in progress and the queue is empty, returns true.</p>
<p>If pausePublishing is true, then return true if either the current publish has completed, or not cloud connected. </p>

</div>
</div>
<a id="acc3222ff156a5b65e3cca85ce199e566" name="acc3222ff156a5b65e3cca85ce199e566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3222ff156a5b65e3cca85ce199e566">&#9670;&#160;</a></span>getDirPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * PublishQueuePosix::getDirPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the directory path set using <a class="el" href="class_publish_queue_posix.html#aebea9de0fa9df57fcae3bda39bead02f" title="Sets the directory to use as the queue directory. This is required!">withDirPath()</a> </p>
<p>The returned path will not end with a slash. </p>

</div>
</div>
<a id="a1e04445ef87bdfdf78fc5d7a2a67ac46" name="a1e04445ef87bdfdf78fc5d7a2a67ac46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e04445ef87bdfdf78fc5d7a2a67ac46">&#9670;&#160;</a></span>getNumEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t PublishQueuePosix::getNumEvents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the total number of events queued. </p>
<p>This is the number of events in the RAM-based queue and the file-based queue. This operation is fast; the file queue length is stored in RAM, so this command does not need to access the file system.</p>
<p>If an event is currently being sent, the result includes this event. </p>

</div>
</div>
<a id="af641a55b459d3a0b465945bc87f8c9e4" name="af641a55b459d3a0b465945bc87f8c9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af641a55b459d3a0b465945bc87f8c9e4">&#9670;&#160;</a></span>instance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp; PublishQueuePosix::instance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the singleton instance of this class. </p>
<p>You cannot construct a <a class="el" href="class_publish_queue_posix.html" title="Class for asynchronous publishing of events.">PublishQueuePosix</a> object as a global variable, stack variable, or with new. You can only request the singleton instance. </p>

</div>
</div>
<a id="a9e26d5d2fb67931b3505bcea140d6b6a" name="a9e26d5d2fb67931b3505bcea140d6b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e26d5d2fb67931b3505bcea140d6b6a">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueuePosix::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock the queue protection mutex. </p>
<p>This is done internally; you probably won't need to call this yourself. It needs to be public for the WITH_LOCK() macro to work properly. </p>

</div>
</div>
<a id="a03dcc28e7d37ac0e565c3868819cd8cb" name="a03dcc28e7d37ac0e565c3868819cd8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03dcc28e7d37ac0e565c3868819cd8cb">&#9670;&#160;</a></span>newRamEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_publish_queue_event.html">PublishQueueEvent</a> * PublishQueuePosix::newRamEvent </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new event structure in RAM. </p>
<p>The PublishEventQueue structure contains a header and is variably sized for the eventData.</p>
<p>May return NULL if eventName or eventData are invalid (too long) or out of memory.</p>
<p>You must delete the result from this method when you are done using it. </p>

</div>
</div>
<a id="a45b3c8a1a1a542d1423bc604e4012840" name="a45b3c8a1a1a542d1423bc604e4012840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b3c8a1a1a542d1423bc604e4012840">&#9670;&#160;</a></span>publish() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueuePosix::publish </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">ttl</td><td>The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="ab078360beeedbc6fe4e0f3fddedcae25" name="ab078360beeedbc6fe4e0f3fddedcae25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab078360beeedbc6fe4e0f3fddedcae25">&#9670;&#160;</a></span>publish() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueuePosix::publish </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="a2bcadc762c4c3e889920997f0e9cd1de" name="a2bcadc762c4c3e889920997f0e9cd1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcadc762c4c3e889920997f0e9cd1de">&#9670;&#160;</a></span>publish() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueuePosix::publish </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for publishing an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="a1fe70d82680b20968aa151d7ec953bc5" name="a1fe70d82680b20968aa151d7ec953bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe70d82680b20968aa151d7ec953bc5">&#9670;&#160;</a></span>publishCommon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PublishQueuePosix::publishCommon </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublishFlags&#160;</td>
          <td class="paramname"><em>flags2</em> = <code>PublishFlags()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eventName</td><td>The name of the event (63 character maximum).</td></tr>
    <tr><td class="paramname">data</td><td>The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</td></tr>
    <tr><td class="paramname">ttl</td><td>The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</td></tr>
    <tr><td class="paramname">flags1</td><td>Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</td></tr>
    <tr><td class="paramname">flags2</td><td>(optional) You can use NO_ACK or WITH_ACK if desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the event was queued or false if it was not.</dd></dl>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded. </p>

</div>
</div>
<a id="ab0898b3b24cfb9eb156d35f74fff12ce" name="ab0898b3b24cfb9eb156d35f74fff12ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0898b3b24cfb9eb156d35f74fff12ce">&#9670;&#160;</a></span>readQueueFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_publish_queue_event.html">PublishQueueEvent</a> * PublishQueuePosix::readQueueFile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fileNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an event from a sequentially numbered file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fileNum</td><td>The file number to read</td></tr>
  </table>
  </dd>
</dl>
<p>May return NULL if file does not exist, or out of memory.</p>
<p>You must delete the result from this method when you are done using it. </p>

</div>
</div>
<a id="a2198975a45927d31a79b37c91addf06e" name="a2198975a45927d31a79b37c91addf06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2198975a45927d31a79b37c91addf06e">&#9670;&#160;</a></span>setPausePublishing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueuePosix::setPausePublishing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause or resume publishing events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to set, true = pause, false = normal operation</td></tr>
  </table>
  </dd>
</dl>
<p>If called while a publish is in progress, that publish will still proceed, but the next event (if any) will not be attempted.</p>
<p>This is used by the automated test tool; you probably won't need to manually manage this under normal circumstances. </p>

</div>
</div>
<a id="ac5c7fb70b600e93c585caf85fbcf8665" name="ac5c7fb70b600e93c585caf85fbcf8665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c7fb70b600e93c585caf85fbcf8665">&#9670;&#160;</a></span>stateConnectWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueuePosix::stateConnectWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler for waiting to connect to the Particle cloud. </p>
<p>Next state: stateWait </p>

</div>
</div>
<a id="aa8b3ff26f26c5bf30fc721feb4bc3e3a" name="aa8b3ff26f26c5bf30fc721feb4bc3e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b3ff26f26c5bf30fc721feb4bc3e3a">&#9670;&#160;</a></span>statePublishWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueuePosix::statePublishWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler for waiting for publish to complete. </p>
<p>Next state: stateWait </p>

</div>
</div>
<a id="a120b8d168445713bfb825cedc613e314" name="a120b8d168445713bfb825cedc613e314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120b8d168445713bfb825cedc613e314">&#9670;&#160;</a></span>stateWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PublishQueuePosix::stateWait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler for waiting to publish. </p>
<p>stateTime and durationMs determine whether to stay in this state waiting, or whether to publish and go into statePublishWait.</p>
<p>Next state: statePublishWait or stateConnectWait </p>

</div>
</div>
<a id="aebea9de0fa9df57fcae3bda39bead02f" name="aebea9de0fa9df57fcae3bda39bead02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebea9de0fa9df57fcae3bda39bead02f">&#9670;&#160;</a></span>withDirPath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp; PublishQueuePosix::withDirPath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dirPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the directory to use as the queue directory. This is required! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirPath</td><td>the pathname, Unix-style with / as the directory separator.</td></tr>
  </table>
  </dd>
</dl>
<p>Typically you create your queue either at the top level ("/myqueue") or in /usr ("/usr/myqueue"). The directory will be created if necessary, however only one level of directory will be created. The parent must already exist.</p>
<p>The dirPath can end with a slash or not, but if you include it, it will be removed.</p>
<p>You must call this as you cannot use the root directory as a queue! </p>

</div>
</div>
<a id="a5963d98e3b9c4e1254cedd4cb0d3a89c" name="a5963d98e3b9c4e1254cedd4cb0d3a89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5963d98e3b9c4e1254cedd4cb0d3a89c">&#9670;&#160;</a></span>withFileQueueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp; PublishQueuePosix::withFileQueueSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the file-based queue size (default is 100) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The maximum number of files to store (one event per file)</td></tr>
  </table>
  </dd>
</dl>
<p>If you exceed this number of events, the oldest event is discarded. </p>

</div>
</div>
<a id="aeb2e79c07a1e1a50016e53d3c75a28d4" name="aeb2e79c07a1e1a50016e53d3c75a28d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2e79c07a1e1a50016e53d3c75a28d4">&#9670;&#160;</a></span>withPublishCompleteUserCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp; PublishQueuePosix::withPublishCompleteUserCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(bool succeeded, const char *eventName, const char *eventData)&gt;&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback function to call with publish is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback function or C++ lambda. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_publish_queue_posix.html" title="Class for asynchronous publishing of events.">PublishQueuePosix</a>&amp;</dd></dl>
<p>The callback has this prototype and can be a function or a C++11 lambda, which allows the callback to be a class method.</p>
<p>void callback(bool succeeded, const char *eventName, const char *eventData)</p>
<p>The parameters are:</p><ul>
<li>succeeded: true if the publish succeeded or false if faled</li>
<li>eventName: The original event name that was published (a copy of it, not the original pointer)</li>
<li>eventData: The original event data</li>
</ul>
<p>Note that this callback will be called from the background thread used for publishing. You should not perform any lengthy operations and you should avoid using large amounts of stack space during this callback. </p>

</div>
</div>
<a id="a9b64145e8d3d2221f1a71a3368b1f29e" name="a9b64145e8d3d2221f1a71a3368b1f29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b64145e8d3d2221f1a71a3368b1f29e">&#9670;&#160;</a></span>withRamQueueSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_publish_queue_posix.html">PublishQueuePosix</a> &amp; PublishQueuePosix::withRamQueueSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RAM based queue size (default is 2) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to set (can be 0, default is 2)</td></tr>
  </table>
  </dd>
</dl>
<p>You can set this to 0 and the events will be stored on the flash file system immediately. This is the best option if the events must not be lost in the event of a sudden reboot.</p>
<p>It's more efficient to have a small RAM-based queue and it eliminates flash wear. Make sure you set the size larger than the maximum number of events you plan to send out in bursts, as if you exceed the RAM queue size, all outstanding events will be moved to files. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_publish_queue_posix_r_k_8h_source.html">PublishQueuePosixRK.h</a></li>
<li>src/PublishQueuePosixRK.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
