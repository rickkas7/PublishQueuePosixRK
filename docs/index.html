<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PublishQueuePosixRK: PublishQueuePosixRK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PublishQueuePosixRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">PublishQueuePosixRK </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <em>Version of publish queue for storing events on the POSIX flash file system</em></p>
<p>This library works a bit differently than <a href="https://github.com/rickkas7/PublishQueueAsyncRK">PublishQueueAsyncRK</a>:</p>
<ul>
<li>It only works with the POSIX flash file system</li>
<li>It can keep a number of events in regular memory for efficiency and reduced flash wear</li>
<li>Or it can always write events to the file system for maximum prevention of event loss</li>
<li>The file system queue supports discarding the oldest events when the size limit is exceeded</li>
</ul>
<h1>Usage</h1>
<p>In many cases, you simply call this from setup:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_publish_queue_posix.html#af641a55b459d3a0b465945bc87f8c9e4">PublishQueuePosix::instance</a>().<a class="code hl_function" href="class_publish_queue_posix.html#ad8590bc7920dad66e85ed60c65ecd867">setup</a>();</div>
<div class="ttc" id="aclass_publish_queue_posix_html_ad8590bc7920dad66e85ed60c65ecd867"><div class="ttname"><a href="class_publish_queue_posix.html#ad8590bc7920dad66e85ed60c65ecd867">PublishQueuePosix::setup</a></div><div class="ttdeci">void setup()</div><div class="ttdoc">You must call this from setup() to initialize this library.</div><div class="ttdef"><b>Definition:</b> PublishQueuePosixRK.cpp:42</div></div>
<div class="ttc" id="aclass_publish_queue_posix_html_af641a55b459d3a0b465945bc87f8c9e4"><div class="ttname"><a href="class_publish_queue_posix.html#af641a55b459d3a0b465945bc87f8c9e4">PublishQueuePosix::instance</a></div><div class="ttdeci">static PublishQueuePosix &amp; instance()</div><div class="ttdoc">Gets the singleton instance of this class.</div><div class="ttdef"><b>Definition:</b> PublishQueuePosixRK.cpp:14</div></div>
</div><!-- fragment --><p>And this from loop:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_publish_queue_posix.html#af641a55b459d3a0b465945bc87f8c9e4">PublishQueuePosix::instance</a>().<a class="code hl_function" href="class_publish_queue_posix.html#ad8590bc7920dad66e85ed60c65ecd867">setup</a>();</div>
</div><!-- fragment --><p>To publish you do something like this:</p>
<div class="fragment"><div class="line">PublishQueuePosix::instance().publish(&quot;testEvent&quot;, buf, PRIVATE | WITH_ACK);</div>
</div><!-- fragment --><h2>RAM Queue</h2>
<p>One parameter you may want to change is the RAM queue size:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_publish_queue_posix.html#af641a55b459d3a0b465945bc87f8c9e4">PublishQueuePosix::instance</a>().<a class="code hl_function" href="class_publish_queue_posix.html#a9b64145e8d3d2221f1a71a3368b1f29e">withRamQueueSize</a>(0);</div>
<div class="ttc" id="aclass_publish_queue_posix_html_a9b64145e8d3d2221f1a71a3368b1f29e"><div class="ttname"><a href="class_publish_queue_posix.html#a9b64145e8d3d2221f1a71a3368b1f29e">PublishQueuePosix::withRamQueueSize</a></div><div class="ttdeci">PublishQueuePosix &amp; withRamQueueSize(size_t size)</div><div class="ttdoc">Sets the RAM based queue size (default is 2)</div><div class="ttdef"><b>Definition:</b> PublishQueuePosixRK.cpp:21</div></div>
</div><!-- fragment --><p>Setting it to 0 means all events will be written to the file system immediately to reduce the chance of losing an event. This has higher overhead and can cause flash wear if you are publishing very frequently.</p>
<p>The default is 2. However, if you normally burst out multiple events at a time, be sure to set the RAM queue size larger than the maximum number of events you burst out. If the RAM queue becomes full, all events will be written to the file system.</p>
<p>The RAM queue is also written to the file system if a publish fails, and right before a reset caused by a software update. However, on other resets the queue will be lost, so if you must not lose an event you should set the RAM queue size to 0.</p>
<h2>File Queue</h2>
<p>The default maximum file queue size is 100, which corresponds to 100 events. Each event takes is stored in a single file. In many cases, an event will fit in a single 512-byte flash sector, but it could require two, or three, for a full 1024 byte event with the overhead.</p>
<p>Also remember that events can only be sent out one per second, so a very long queue will take a while to send!</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="class_publish_queue_posix.html#af641a55b459d3a0b465945bc87f8c9e4">PublishQueuePosix::instance</a>().<a class="code hl_function" href="class_publish_queue_posix.html#a5963d98e3b9c4e1254cedd4cb0d3a89c">withFileQueueSize</a>(50);</div>
<div class="ttc" id="aclass_publish_queue_posix_html_a5963d98e3b9c4e1254cedd4cb0d3a89c"><div class="ttname"><a href="class_publish_queue_posix.html#a5963d98e3b9c4e1254cedd4cb0d3a89c">PublishQueuePosix::withFileQueueSize</a></div><div class="ttdeci">PublishQueuePosix &amp; withFileQueueSize(size_t size)</div><div class="ttdoc">Sets the file-based queue size (default is 100)</div><div class="ttdef"><b>Definition:</b> PublishQueuePosixRK.cpp:32</div></div>
</div><!-- fragment --><h1>Dependencies</h1>
<p>This library depends on two additional libraries:</p>
<ul>
<li><a href="https://github.com/rickkas7/SequentialFileRK">SequentialFileRK</a> manages the queue on the flash file system</li>
<li><a href="https://github.com/rickkas7/BackgroundPublishRK">BackgroundPublishRK</a> handles publishing from a background thread</li>
</ul>
<h1>API</h1>
<hr  />
<h2>void <a class="el" href="class_publish_queue_posix.html#ad8590bc7920dad66e85ed60c65ecd867" title="You must call this from setup() to initialize this library.">PublishQueuePosix::setup()</a></h2>
<p>You must call this from setup() to initialize this library.</p>
<div class="fragment"><div class="line">void setup()</div>
</div><!-- fragment --><hr  />
<h2>void <a class="el" href="class_publish_queue_posix.html#a157e71d583df634b290b5ab3e08156f5" title="You must call the loop method from the global loop() function!">PublishQueuePosix::loop()</a></h2>
<p>You must call the loop method from the global loop() function!</p>
<div class="fragment"><div class="line">void loop()</div>
</div><!-- fragment --><hr  />
<h2><a class="el" href="class_publish_queue_posix.html" title="Class for asynchronous publishing of events.">PublishQueuePosix</a> &amp; <a class="el" href="class_publish_queue_posix.html#a9b64145e8d3d2221f1a71a3368b1f29e" title="Sets the RAM based queue size (default is 2)">PublishQueuePosix::withRamQueueSize(size_t size)</a></h2>
<p>Sets the RAM based queue size (default is 2)</p>
<div class="fragment"><div class="line">PublishQueuePosix &amp; withRamQueueSize(size_t size)</div>
</div><!-- fragment --><h3>Parameters</h3>
<ul>
<li><code>size</code> The size to set (can be 0, default is 2)</li>
</ul>
<p>You can set this to 0 and the events will be stored on the flash file system immediately. This is the best option if the events must not be lost in the event of a sudden reboot.</p>
<p>It's more efficient to have a small RAM-based queue and it eliminates flash wear. Make sure you set the size larger than the maximum number of events you plan to send out in bursts, as if you exceed the RAM queue size, all outstanding events will be moved to files.</p>
<hr  />
<h2>size_t <a class="el" href="class_publish_queue_posix.html#a7e9de217df46af588b7b95c5f3ae339d" title="Gets the size of the RAM queue.">PublishQueuePosix::getRamQueueSize() const</a></h2>
<p>Gets the size of the RAM queue.</p>
<div class="fragment"><div class="line">size_t getRamQueueSize() const</div>
</div><!-- fragment --><hr  />
<h2><a class="el" href="class_publish_queue_posix.html" title="Class for asynchronous publishing of events.">PublishQueuePosix</a> &amp; <a class="el" href="class_publish_queue_posix.html#a5963d98e3b9c4e1254cedd4cb0d3a89c" title="Sets the file-based queue size (default is 100)">PublishQueuePosix::withFileQueueSize(size_t size)</a></h2>
<p>Sets the file-based queue size (default is 100)</p>
<div class="fragment"><div class="line">PublishQueuePosix &amp; withFileQueueSize(size_t size)</div>
</div><!-- fragment --><h3>Parameters</h3>
<ul>
<li><code>size</code> The maximum number of files to store (one event per file)</li>
</ul>
<p>If you exceed this number of events, the oldest event is discarded.</p>
<hr  />
<h2>size_t <a class="el" href="class_publish_queue_posix.html#a4ceda8818c2265cfd11ec63ecbe63b42" title="Gets the file queue size.">PublishQueuePosix::getFileQueueSize() const</a></h2>
<p>Gets the file queue size.</p>
<div class="fragment"><div class="line">size_t getFileQueueSize() const</div>
</div><!-- fragment --><hr  />
<h2><a class="el" href="class_publish_queue_posix.html" title="Class for asynchronous publishing of events.">PublishQueuePosix</a> &amp; <a class="el" href="class_publish_queue_posix.html#aebea9de0fa9df57fcae3bda39bead02f" title="Sets the directory to use as the queue directory. This is required!">PublishQueuePosix::withDirPath(const char * dirPath)</a></h2>
<p>Sets the directory to use as the queue directory. This is required!</p>
<div class="fragment"><div class="line">PublishQueuePosix &amp; withDirPath(const char * dirPath)</div>
</div><!-- fragment --><h3>Parameters</h3>
<ul>
<li><code>dirPath</code> the pathname, Unix-style with / as the directory separator.</li>
</ul>
<p>Typically you create your queue either at the top level ("/myqueue") or in /usr ("/usr/myqueue"). The directory will be created if necessary, however only one level of directory will be created. The parent must already exist.</p>
<p>The dirPath can end with a slash or not, but if you include it, it will be removed.</p>
<p>You must call this as you cannot use the root directory as a queue!</p>
<hr  />
<h2>const char * <a class="el" href="class_publish_queue_posix.html#acc3222ff156a5b65e3cca85ce199e566" title="Gets the directory path set using withDirPath()">PublishQueuePosix::getDirPath() const</a></h2>
<p>Gets the directory path set using withDirPath()</p>
<div class="fragment"><div class="line">const char * getDirPath() const</div>
</div><!-- fragment --><p>The returned path will not end with a slash.</p>
<hr  />
<h2>bool <a class="el" href="class_publish_queue_posix.html#a2bcadc762c4c3e889920997f0e9cd1de" title="Overload for publishing an event.">PublishQueuePosix::publish(const char * eventName, PublishFlags flags1, PublishFlags flags2)</a></h2>
<p>Overload for publishing an event.</p>
<div class="fragment"><div class="line">bool publish(const char * eventName, PublishFlags flags1, PublishFlags flags2)</div>
</div><!-- fragment --><h3>Parameters</h3>
<ul>
<li><code>eventName</code> The name of the event (63 character maximum).</li>
<li><code>flags1</code> Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</li>
<li><code>flags2</code> (optional) You can use NO_ACK or WITH_ACK if desired.</li>
</ul>
<h3>Returns</h3>
<p>true if the event was queued or false if it was not.</p>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.</p>
<hr  />
<h2>bool <a class="el" href="class_publish_queue_posix.html#ab078360beeedbc6fe4e0f3fddedcae25" title="Overload for publishing an event.">PublishQueuePosix::publish(const char * eventName, const char * data, PublishFlags flags1, PublishFlags flags2)</a></h2>
<p>Overload for publishing an event.</p>
<div class="fragment"><div class="line">bool publish(const char * eventName, const char * data, PublishFlags flags1, PublishFlags flags2)</div>
</div><!-- fragment --><h3>Parameters</h3>
<ul>
<li><code>eventName</code> The name of the event (63 character maximum).</li>
<li><code>data</code> The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</li>
<li><code>flags1</code> Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</li>
<li><code>flags2</code> (optional) You can use NO_ACK or WITH_ACK if desired.</li>
</ul>
<h3>Returns</h3>
<p>true if the event was queued or false if it was not.</p>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.</p>
<hr  />
<h2>bool <a class="el" href="class_publish_queue_posix.html#a45b3c8a1a1a542d1423bc604e4012840" title="Overload for publishing an event.">PublishQueuePosix::publish(const char * eventName, const char * data, int ttl, PublishFlags flags1, PublishFlags flags2)</a></h2>
<p>Overload for publishing an event.</p>
<div class="fragment"><div class="line">bool publish(const char * eventName, const char * data, int ttl, PublishFlags flags1, PublishFlags flags2)</div>
</div><!-- fragment --><h3>Parameters</h3>
<ul>
<li><code>eventName</code> The name of the event (63 character maximum).</li>
<li><code>data</code> The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</li>
<li><code>ttl</code> The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</li>
<li><code>flags1</code> Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</li>
<li><code>flags2</code> (optional) You can use NO_ACK or WITH_ACK if desired.</li>
</ul>
<h3>Returns</h3>
<p>true if the event was queued or false if it was not.</p>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.</p>
<hr  />
<h2>bool <a class="el" href="class_publish_queue_posix.html#a1fe70d82680b20968aa151d7ec953bc5" title="Common publish function. All other overloads lead here. This is a pure virtual function,...">PublishQueuePosix::publishCommon(const char * eventName, const char * data, int ttl, PublishFlags flags1, PublishFlags flags2)</a></h2>
<p>Common publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses.</p>
<div class="fragment"><div class="line">virtual bool publishCommon(const char * eventName, const char * data, int ttl, PublishFlags flags1, PublishFlags flags2)</div>
</div><!-- fragment --><h3>Parameters</h3>
<ul>
<li><code>eventName</code> The name of the event (63 character maximum).</li>
<li><code>data</code> The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).</li>
<li><code>ttl</code> The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.</li>
<li><code>flags1</code> Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.</li>
<li><code>flags2</code> (optional) You can use NO_ACK or WITH_ACK if desired.</li>
</ul>
<h3>Returns</h3>
<p>true if the event was queued or false if it was not.</p>
<p>This function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.</p>
<hr  />
<h2>void <a class="el" href="class_publish_queue_posix.html#ae25ae4430b968cee10a91c72c9ed41f4" title="If there are events in the RAM queue, write them to files in the flash file system.">PublishQueuePosix::writeQueueToFiles()</a></h2>
<p>If there are events in the RAM queue, write them to files in the flash file system.</p>
<div class="fragment"><div class="line">void writeQueueToFiles()</div>
</div><!-- fragment --><hr  />
<h2>void <a class="el" href="class_publish_queue_posix.html#afdd1346256db17582e210c544735bc66" title="Empty both the RAM and file based queues. Any queued events are discarded.">PublishQueuePosix::clearQueues()</a></h2>
<p>Empty both the RAM and file based queues. Any queued events are discarded.</p>
<div class="fragment"><div class="line">void clearQueues()</div>
</div><!-- fragment --><hr  />
<h2>void <a class="el" href="class_publish_queue_posix.html#a2198975a45927d31a79b37c91addf06e" title="Pause or resume publishing events.">PublishQueuePosix::setPausePublishing(bool value)</a></h2>
<p>Pause or resume publishing events.</p>
<div class="fragment"><div class="line">void setPausePublishing(bool value)</div>
</div><!-- fragment --><h3>Parameters</h3>
<ul>
<li><code>value</code> The value to set, true = pause, false = normal operation</li>
</ul>
<p>If called while a publish is in progress, that publish will still proceed, but the next event (if any) will not be attempted.</p>
<p>This is used by the automated test tool; you probably won't need to manually manage this under normal circumstances.</p>
<hr  />
<h2>bool <a class="el" href="class_publish_queue_posix.html#ae10fe9f388241227f5e431a23ac0c980" title="Gets the state of the pause publishing flag.">PublishQueuePosix::getPausePublishing() const</a></h2>
<p>Gets the state of the pause publishing flag.</p>
<div class="fragment"><div class="line">bool getPausePublishing() const</div>
</div><!-- fragment --> <hr  />
<h2>bool <a class="el" href="class_publish_queue_posix.html#aaf40ee8cdda04825a5cd39a0e590ee29" title="Determine if it&#39;s a good time to go to sleep.">PublishQueuePosix::getCanSleep() const</a></h2>
<p>Determine if it's a good time to go to sleep. Added in version 0.0.3.</p>
<div class="fragment"><div class="line">bool getCanSleep() const</div>
</div><!-- fragment --><p>If a publish is not in progress and the queue is empty, returns true.</p>
<p>If pausePublishing is true, then return true if either the current publish has completed, or not cloud connected.</p>
<hr  />
<h2>size_t <a class="el" href="class_publish_queue_posix.html#a1e04445ef87bdfdf78fc5d7a2a67ac46" title="Gets the total number of events queued.">PublishQueuePosix::getNumEvents()</a></h2>
<p>Gets the total number of events queued.</p>
<div class="fragment"><div class="line">size_t getNumEvents()</div>
</div><!-- fragment --><p>This is the number of events in the RAM-based queue and the file-based queue. This operation is fast; the file queue length is stored in RAM, so this command does not need to access the file system.</p>
<p>If an event is currently being sent, the result includes this event.</p>
<hr  />
<h2>void <a class="el" href="class_publish_queue_posix.html#a9e26d5d2fb67931b3505bcea140d6b6a" title="Lock the queue protection mutex.">PublishQueuePosix::lock()</a></h2>
<p>Lock the queue protection mutex.</p>
<div class="fragment"><div class="line">void lock()</div>
</div><!-- fragment --><p>This is done internally; you probably won't need to call this yourself. It needs to be public for the WITH_LOCK() macro to work properly.</p>
<hr  />
<h2>bool <a class="el" href="class_publish_queue_posix.html#ad8d31a0910bf63b36cdf44e19e7e6f05" title="Attempt the queue protection mutex.">PublishQueuePosix::tryLock()</a></h2>
<p>Attempt the queue protection mutex.</p>
<div class="fragment"><div class="line">bool tryLock()</div>
</div><!-- fragment --><hr  />
<h2>void <a class="el" href="class_publish_queue_posix.html#ad5179e3090335f23f2f882f274c5a7d2" title="Unlock the queue protection mutex.">PublishQueuePosix::unlock()</a></h2>
<p>Unlock the queue protection mutex.</p>
<div class="fragment"><div class="line">void unlock()</div>
</div><!-- fragment --><h1>Version History</h1>
<h2>0.0.6 (2023-10-22)</h2>
<ul>
<li>Added <code>withPublishCompleteUserCallback()</code> to set a callback function or C++ lambda that is called when publish is complete (successfully or not).</li>
</ul>
<h2>0.0.5 (2022-10-06)</h2>
<ul>
<li>I believe I fixed a situation where getCanSleep() can return true during the waitAfterConnect period after connecting even though there are events in the queue.</li>
</ul>
<h2>0.0.4 (2022-06-21)</h2>
<ul>
<li>When setPausePublishing(false), set the canSleep flag to false if there are events in the queue</li>
<li>The canSleep flag was not set after sending the last event</li>
</ul>
<h2>0.0.3 (2022-03-07)</h2>
<ul>
<li>Added getCanSleep() method to determine if the queue has been sent and it's safe to sleep.</li>
</ul>
<h2>0.0.2 (2022-01-28)</h2>
<ul>
<li>Rename BackgroundPublishRK class to BackgroundPublishRK to avoid conflict with a class of the same name in Tracker Edge.</li>
</ul>
<h2>0.0.1 (2021-04-28)</h2>
<ul>
<li>Initial version </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
